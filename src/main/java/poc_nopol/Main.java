package poc_nopol;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StringWriter;
import java.lang.annotation.Annotation;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.io.IOUtils;

import spoon.Launcher;
import spoon.reflect.declaration.CtAnnotation;
import spoon.reflect.declaration.CtAnnotationType;
import spoon.reflect.declaration.CtMethod;
import spoon.reflect.declaration.CtType;
import spoon.support.reflect.declaration.CtAnnotationTypeImpl;



public class Main {

	public final static char fileSeparator = '/';
	public final static String outputsDir = "outputs";
	public final static String evoOutput = "generatedTests";
	
	public static List<CtMethod>  keptMethods = new ArrayList<CtMethod>();
	public static List<CtMethod>  removedMethods = new ArrayList<CtMethod>();
	public static Map<String, String> patches = new HashMap<String,String>();
	
	public static void main(String[] args) throws IOException, ParseException {
		
		String projectFolder = null;
		String cpClassFolder = null;
		String cpTestFolder = null;
		String srcClassFolder = null;
		String srcTestFolder = null;
		String destSrcTestFolder = null;
		String destCpTestFolder = null;
		String newTestFolder = null;
		String dependencies = null;
		
        Options options = new Options();
        //options.addOption("typeOfBug", true, "type of bug (Chart, Math, Lang or Time");
        //options.addOption("numberOfBug", true, "number of bug (ex: 85 for Math85)");
        options.addOption("projectFolder", true, "project folder (ex: bugs/Math_85)");
        options.addOption("cpClassFolder", true, "classes files (ex: project/target/classes)");
        options.addOption("cpTestFolder", true, "classes test files (ex: project/target/test-classes)");
        options.addOption("srcClassFolder", true, "location of project files (ex: project/src/java)");
        options.addOption("srcTestFolder", true, "location of tests files (ex: project/src/test)");
        options.addOption("newTestFolder", true, "location of new test generated by evoSuite. default: generatedTests");
        options.addOption("destSrcTestFolder", true, "java files where new tests will be added after validation. (ex: project/src/test) default: srcTestFolder");
        options.addOption("destCpTestFolder", true, "java files where new tests will be compiled after validation. (ex: project/target/test-classes) default: cpTestFolder");
        options.addOption("dependencies", true, "all other class or jar required for the news tests. cpClassFolde & cpTestFolder are not necessary. (ex: junit, hamcrest, evosuite)");
        
        CommandLineParser parser = new DefaultParser();
        CommandLine cmd = parser.parse(options, args);
        
        if (cmd.getOptionValue("projectFolder") != null) {
        	projectFolder = cmd.getOptionValue("projectFolder");
        }
        
        if (cmd.getOptionValue("cpClassFolder") != null) {
        	cpClassFolder = cmd.getOptionValue("cpClassFolder");
        }
        
        if (cmd.getOptionValue("cpTestFolder") != null) {
        	cpTestFolder = cmd.getOptionValue("cpTestFolder");
        }
        
        if (cmd.getOptionValue("srcClassFolder") != null) {
        	srcClassFolder = cmd.getOptionValue("srcClassFolder");
        }
        
        if (cmd.getOptionValue("srcTestFolder") != null) {
        	srcTestFolder = cmd.getOptionValue("srcTestFolder");
        }
        
        destSrcTestFolder = srcTestFolder;
        if (cmd.getOptionValue("destSrcTestFolder") != null) {
        	destSrcTestFolder = cmd.getOptionValue("destSrcTestFolder");
        }
        
        destCpTestFolder = cpTestFolder;
        if (cmd.getOptionValue("destCpTestFolder") != null) {
        	destCpTestFolder = cmd.getOptionValue("destCpTestFolder");
        }
        
        if (cmd.getOptionValue("newTestFolder") != null) {
        	newTestFolder = cmd.getOptionValue("newTestFolder");
        }
        
        if (cmd.getOptionValue("dependencies") != null) {
        	dependencies = cmd.getOptionValue("dependencies");
        }
        
        if(!cmd.hasOption("cpClassFolder") || !cmd.hasOption("cpTestFolder") ||
        		!cmd.hasOption("srcClassFolder") || !cmd.hasOption("srcTestFolder") || 
        		!cmd.hasOption("newTestFolder")) {
    		HelpFormatter formatter = new HelpFormatter();
    		formatter.printHelp( "list des parametres", options );
    		System.exit(0);
    	}
        
        tryAllTests(cpClassFolder, cpTestFolder, srcClassFolder, srcTestFolder, destSrcTestFolder, destCpTestFolder, newTestFolder, dependencies, true);

	}

	
	/**
	 * this method analyze all java class in generatedTestDir and return paths composed of package + class
	 * @param generatedTestDir
	 * @param classPath
	 * @return
	 */
	public static List<String> getNewTestsFilesPaths(String generatedTestFolder, String classPath){
		
		List<String> testsFiles = new ArrayList<String>();
		System.out.println("--------------------------------------------------");
		System.out.println(" ##### Search tests files path ##### ");
		Launcher spoon = new Launcher();
		spoon.getEnvironment().setAutoImports(true);
		spoon.addInputResource(generatedTestFolder);
		spoon.getEnvironment().setSourceClasspath(classPath.split(File.pathSeparator));
		spoon.buildModel();

		//getannotatedMethod.. could be better
		for(CtType<?> clazz : spoon.getFactory().Class().getAll()){
			String filePath = clazz.getPackage().toString().replace('.', fileSeparator)+"/"+clazz.getSimpleName();
			System.out.println("[FOUND] "+filePath);
			testsFiles.add(filePath);
		}
		
		return testsFiles;
	}
	
	
	/**
	 * this method analyze all java class in generatedTestDir and return a list of all Junit method
	 * @param generatedTestDir
	 * @param classPath
	 * @return
	 */
	public static List<CtMethod> getNewTestsMethods(String generatedTestFolder, String classPath){
		List<CtMethod>  testsMethods = new ArrayList<CtMethod>();

		System.out.println("--------------------------------------------------");
		System.out.println(" ##### Search tests methods ##### ");
		Launcher spoon = new Launcher();
		spoon.getEnvironment().setAutoImports(true);
		spoon.addInputResource(generatedTestFolder);
		spoon.getEnvironment().setSourceClasspath(classPath.split(File.pathSeparator));
		spoon.buildModel();
		//getannotatedMethod.. could be better
		for(CtType<?> clazz : spoon.getFactory().Class().getAll()){
			methodLoop:
				for(CtMethod<?> method : clazz.getAllMethods()){
					for(CtAnnotation<? extends Annotation> annotation : method.getAnnotations()){
						if(annotation.getSignature().equals("@org.junit.Test")){
							System.out.println("[FOUND] "+method.getSignature());
							testsMethods.add(method);
							continue methodLoop;
						}
					}
				}
		}
		
		return testsMethods;
	}

	/**
	 * 
	 * @param testFolder
	 * @param cpClassFolder
	 * @param cpTestFolder
	 * @param testFiles
	 */
	public static void compileTests(String destCpTestFolder, String classPath, List<String> testFiles){
		
		List<String> cmd = new ArrayList<String>();
		cmd.add("./compile_evo.sh");
		cmd.add(classPath);
		cmd.add(destCpTestFolder);
		cmd.addAll(testFiles);
		
		//System.out.println("./compile_evo.sh "+cp+" "+destCpTestFolder);

		ProcessBuilder pb = new ProcessBuilder(cmd);
		Map<String, String> env = pb.environment();
		Process p = null;
		try {
			p = pb.start();
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
	}
	
	/**
	 * 
	 * @param typeOfBug
	 * @param numberOfBug
	 * @param bugFolder
	 * @param numberOfTurn
	 * @return
	 * @throws PatchNotFoundException 
	 */
	public static String NopolPatchGeneration(String cpClassFolder,String  cpTestFolder, 
			String srcClassFolder, String srcTestFolder, String destSrcTestFolder, 
			String destCpTestFolder, String dependencies, int numberOfTurn) {
		
		String sources = srcClassFolder+File.pathSeparatorChar+srcTestFolder+File.pathSeparatorChar+destSrcTestFolder;
		String cp = cpClassFolder+File.pathSeparatorChar+cpTestFolder+File.pathSeparatorChar+destCpTestFolder+File.pathSeparatorChar+dependencies;
		List<String> cmd = new ArrayList<String>();
		cmd.add("./nopol_launcher.sh");
		cmd.add(cp);
		cmd.add(sources);
		
		ProcessBuilder pb = new ProcessBuilder(cmd);
		Map<String, String> env = pb.environment();
		Process p = null;
		try {
			//pb.inheritIO(); //doesnt work caus maven http://stackoverflow.com/questions/17525441/redirect-i-o-of-subprocess-in-java-why-doesnt-processbuilder-inheritio-work
			p = pb.start();
		} catch (IOException e1) {
			e1.printStackTrace();
		}
		
		
		BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
		StringBuilder builder = new StringBuilder();
		String line = null;
		try {
			while ( (line = reader.readLine()) != null) {
				builder.append(line);
				builder.append(System.getProperty("line.separator"));
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
		String result = builder.toString();
		
		return result;
	}
	
	/**
	 * 
	 * @param cpClassFolder
	 * @param cpTestFolder
	 * @param srcClassFolder
	 * @param srcTestFolder
	 * @param destSrcTestDir
	 * @param newTestDir
	 * @param dependencies
	 */
	public static void tryAllTests(String cpClassFolder, String cpTestFolder, 
			String srcClassFolder, String srcTestFolder, String destSrcTestFolder, 
			String destCpTestFolder, String newTestFolder, String dependencies, boolean generateTest){
		
		//create dest folders if not exist
		new File(destSrcTestFolder).mkdirs();
		new File(destCpTestFolder).mkdirs();
		
		String result = null;
		String className = null;
		
		//build classpath
		String classPath = cpClassFolder+File.pathSeparatorChar+dependencies;
		
		
		System.out.println("--------------------------------------------------");
		System.out.println(" ##### launch nopol without new tests ##### ");
		
		result = NopolPatchGeneration(cpClassFolder, cpTestFolder, srcClassFolder, srcTestFolder, destSrcTestFolder, destCpTestFolder, dependencies, -1);
		if(!result.contains("----PATCH FOUND----")){
			System.out.println("No patch found without new tests");
			extractPatch(result,"basic");
			SaveResult(result, "basic");
			return;
		}
		extractPatch(result,"basic");
		SaveResult(result, "basic");
		
		System.out.println("patch found, let's try with evosuite");
		className = extractClassPathFromNopolStdOut(result);
		
		if(generateTest){
			System.out.println(" #### run EvoSuite on "+className+" #### ");
			generateEvoSuiteTests(newTestFolder, dependencies, className);
		}
		
		List<String> testsFiles = getNewTestsFilesPaths(newTestFolder, classPath);
		List<CtMethod> testsMethods = getNewTestsMethods(newTestFolder, classPath);

		System.out.println("###########################################");
		System.out.println("######## start to try each methods ########");
		System.out.println("###########################################");
		List<String> filesToCompile = new ArrayList<String>();
		int numberOfTurn = 0;
		for(CtMethod method : testsMethods){
			System.out.println("--------------------------------------------------");
			System.out.println("# TEST METHOD : "+method.getSignature());
			System.out.println("--------------------------------------------------");

			System.out.println("### Remove EvoSuite ");
			filesToCompile = new ArrayList<String>();
			Launcher spoonLauncher = new Launcher();
			spoonLauncher.addProcessor(new TestSelectionProcessor(method, keptMethods));
			spoonLauncher.addProcessor(new RemoveEvosuiteEffectsProcessor());
			spoonLauncher.addInputResource(newTestFolder);
			spoonLauncher.getEnvironment().setSourceClasspath(classPath.split(File.pathSeparator));
			spoonLauncher.setOutputDirectory(destSrcTestFolder);
			spoonLauncher.run();
			//spoonLauncher.run(new String[]{"-i",newTestFolder,"--source-classpath",classPath,"-o",destSrcTestFolder,"-d",cpTestFolder,"--compile"});

			System.out.println("### Recompile Tests ");
			for(String testPath : testsFiles){
				filesToCompile.add(destSrcTestFolder+fileSeparator+testPath+".java");
			}
			compileTests( destCpTestFolder, classPath, filesToCompile);
			

			System.out.println("### Launch Nopol");
			result = NopolPatchGeneration(cpClassFolder, cpTestFolder, srcClassFolder, srcTestFolder, destSrcTestFolder, destCpTestFolder, dependencies, numberOfTurn);
			if(result.contains("----PATCH FOUND----")){
				System.out.println("### ----- PATCH FOUND -----");
				System.out.println("### METHOD KEPT : "+method.getSignature());
				keptMethods.add(method);
			}
			else{
				System.out.println("### ----- NO PATCH FOUND -----");
				System.out.println("### METHOD REMOVED : "+method.getSignature());
				removedMethods.add(method);
			}
			SaveResult(result, numberOfTurn+"_"+method.getSimpleName());
			extractPatch(result,method.getSimpleName());
			
			
			numberOfTurn++;
		}
		
		System.out.println("### End of program. Recompile keeping all good tests");
		filesToCompile = new ArrayList<String>();
		Launcher lastLauncher = new Launcher();
		lastLauncher.addProcessor(new TestSelectionProcessor(null, keptMethods));
		lastLauncher.addProcessor(new RemoveEvosuiteEffectsProcessor());
		lastLauncher.addInputResource(newTestFolder);
		lastLauncher.getEnvironment().setSourceClasspath(classPath.split(File.pathSeparator));
		lastLauncher.setOutputDirectory(destSrcTestFolder);
		lastLauncher.run();
		//spoonLauncher.run(new String[]{"-i",newTestFolder,"--source-classpath",classPath,"-o",destSrcTestFolder,"-d",cpTestFolder,"--compile"});

		System.out.println("### Recompile Tests ");
		for(String testPath : testsFiles){
			filesToCompile.add(destSrcTestFolder+fileSeparator+testPath+".java");
		}
		compileTests( destCpTestFolder, classPath, filesToCompile);
		
	}
	
	/**
	 * this method use nopol output. the bound with nopol syntax is important and can fail
	 * if nopol change its output.
	 * @param result
	 * @param methodName
	 */
	private static void extractPatch(String result, String methodName) {
		if(!result.contains("----PATCH FOUND----")){
			patches.put(methodName, null);
			return;
		}
		String[] results = result.split("----PATCH FOUND----")[1].split(":");
		String patch = results[results.length-1].replace("\n", "");
		patches.put(methodName, patch);
	}


	/**
	 * 
	 * @param newTestFolder
	 * @param classPath
	 * @param className
	 * @return
	 */
	public static String generateEvoSuiteTests(String newTestFolder, String classPath, String className){
		List<String> cmd = new ArrayList<String>();
		cmd.add("java");
		cmd.add("-jar");
		cmd.add("evosuite-1.0.2.jar");
		cmd.add("-class");
		cmd.add(className);
		cmd.add("-projectCP");
		cmd.add(classPath);
		cmd.add("-generateSuite");
		cmd.add("-Dsearch_budget=30");
		cmd.add("-Dstopping_condition=MaxTime");
		cmd.add("-Dno_runtime_dependency=true");
		cmd.add("-Dtest_dir="+newTestFolder);
		
		ProcessBuilder pb = new ProcessBuilder(cmd);
		System.out.println("ABCDEF== "+pb.command());
		Map<String, String> env = pb.environment();
		Process p = null;
		try {
			//pb.inheritIO(); //doesnt work caus maven http://stackoverflow.com/questions/17525441/redirect-i-o-of-subprocess-in-java-why-doesnt-processbuilder-inheritio-work
			p = pb.start();
		} catch (IOException e1) {
			e1.printStackTrace();
		}
		
		BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
		StringBuilder builder = new StringBuilder();
		String line = null;
		try {
			while ( (line = reader.readLine()) != null) {
				builder.append(line);
				builder.append(System.getProperty("line.separator"));
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
		String result = builder.toString();
		
		try{
			File file = new File("evoOutput.txt");
			FileWriter fileWriter = new FileWriter(file);
			fileWriter.write(result);
			fileWriter.flush();
			fileWriter.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		
		return newTestFolder;
	}
	
	public static void SaveResult(String result, String fileName){
		try{
			new File(outputsDir).mkdirs();
			File file = new File(outputsDir+fileSeparator+fileName+".txt");
			FileWriter fileWriter = new FileWriter(file);
			fileWriter.write(result);
			fileWriter.flush();
			fileWriter.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	
	public static String extractClassPathFromNopolStdOut(String stdOut){
		//extract file path of patch.
		String output = stdOut.split("----PATCH FOUND----")[1].replace("\n", "").replace("\r", "");
    	String[] datas = output.split(":");
    	return datas[0];
	}
	
}
